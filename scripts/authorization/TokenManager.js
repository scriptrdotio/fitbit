/** Script ACLs do not delete 
 read=nobody 
write=nobody
execute=authenticated 
  **/ 
 const TYPE = "healthapi";
const SOURCE = "fitbit";
var useLegacyStorage = false; // set to true if you need to keep backward compatibility with former versions 

/**
 * This module is in charge of obtaining an OAuth 2.0 access token, either from 
 * a provided code or from a provided refresh token, for a given user.
 * The module stores the access and refresh token in the global storage
 * storage.global.fitbit_username_fibitAccessToken
 * storage.global.fitbit_username_fitbitRefreshToken
 * @module TokenManager
 */

var document = require("document");
var config = require("../config.js");
var util = require("../util.js");
var http = require("http");

/** 
 * Retrieve the access and refresh tokens of a given user from te global storage
 * This method can throw exceptions
 * @method getPersistedTokens
 * @param {String} username : the name of the user for who we need the corresponding tokens
 * @return {Object} {accessToken, refreshToken}
 */
function getPersistedTokens(username) {

    var accessToken = "";
    var refreshToken = "";    
    if (useLegacyStorage) {

        accessToken = storage.global["fitbit_" + username + "_fibitAccessToken"];
        refreshToken = storage.global["fitbit_" + username + "_fitbitRefreshToken"];
    }else {

        var key = _getDocumentKey(username);    
        var resp = document.get(key);
        if (resp.metadata.status == "failure") {        

            log.error("TokenManager.getPersistedTokens:\n" + JSON.stringify(resp));
            throw resp;
        }
    }

    if (!accessToken || !refreshToken) {

        throw {
            "errorCode": "Missing_Access_Token",
            "errorDetail": "Could not find an access token or a refresh token for this user " + username
        };
    }

    return {
        "accessToken": accessToken,
        "refreshToken": refreshToken
    };
}

/**
 * Invoke fitbit authorization API to obtain an access token
 * This method can throw exceptions
 * @method getAccessToken
 * @param {Object} params
 *	{String} params.state : the state that was generated by fitbt/config when issuing the auth request
 *	{String} params.code : the OAuth code returned buy fitbit further to the auth request, to be exchanged for a
 *  an access token
 * @return {Object} the API response. You do not need it normally. Get the tokens using getPersistedTokens()
 */
function getAccessToken(params) {

    if (!params) {

        throw {
            "errorCode": "Invalid_Parameter",
            "errorDetail": "getAccessToken - params cannot be null or empty"
        };
    }

    var params = {

        "state": params.state,
        "code": params.code,
        "grant_type": "authorization_code",
        "redirect_uri": config.redirect_uri
    };

    return this._getToken(params);
}

/**
 * Invoke fitbit authorization API to obtain an access token using a refresh token
 * This method can throw exceptions
 * @method getAccessToken
 * @param {String} username : the name of the user for who we need to obtain a new access token
 * @return {Object} the API response. You do not need it normally. Get the tokens using getPersistedTokens()
 */
function refreshAccessToken(username) {

    if (!username) {

        throw {
            "errorCode": "Invalid_Parameter",
            "errorDetail": "You need to pass a username to refresh the token"
        };
    };

    var refreshToken = getPersistedTokens(username).refreshToken;
    var refreshParams = {

        "grant_type": "refresh_token",
        "refresh_token": refreshToken
    };

    return this._getToken(refreshParams, username);
}

function _getToken(params, username) {

    var requestObject = {  

        "url": config.accessTokenUrl,
        "method": "POST",
        "params": params,
        "headers": {
            "Authorization": "Basic " +  btoa(config.client_id + ":" + config.client_secret),
            "Content-Type": "application/x-www-form-urlencoded"
        }
    };

    var response = http.request(requestObject);
    console.log("Received response " +  JSON.stringify(response));
    var responseBodyStr = response.body;
    var responseObj = null;
    if (response.status == "200") {

        if (response.headers["Content-Type"].indexOf("application/json") > -1) {

            responseObj = JSON.parse(responseBodyStr);

            // retrieve the username who owns this token using the persisted state-username mapping
            var username = username ? username : storage.global["fitbit_state_" + params.state];
            if (!username) {

                throw {

                    "errorCode": "Inconsistency_Error",
                    "errorDetail": "Could not find username " + username + " in store to store the tokens"
                };
            }

            // clean-up the state
            storage.global["fitbit_state_" + params.state] = null;
            saveTokens(username, responseObj);            
            return responseObj;
        }else {

            throw {
                "errorCode": "Unexpected_Response",
                "errorDetail": responseBodyStr
            }
        }    
    }else {

        var errorObj = "";
        try {

            errorObj = JSON.parse(response.body);
            errorObj = errorObj.errors;
        }catch(e) {
            errorObj = JSON.parse(response);
        };

        throw {

            "errorCode": "Authorization_Failed",
            "errorDetail": errorObj
        };
    }
}	

function saveTokens(username, dto) {

    if (useLegacyStorage) {
        
        // persist the received access and refresh tokens in the storage and associate them to the targeted user
        storage.global["fitbit_" + username + "_fibitAccessToken"] = dto["access_token"];
        storage.global["fitbit_" + username + "_fitbitRefreshToken"] = dto["refresh_token"];
    }else {

        var fields = {

            type: TYPE,
            key: _getDocumentKey(username),
            accessToken: dto.access_token,
            username: username
        };

        if (dto.refresh_token){
            fields.refreshToken = dto.refresh_token
        }

        if (dto.userId) {
            fields.userId = dto.userId
        }

        var resp = document.save(fields);
        if (resp.metadata.status == "failure") {        

            log.error("TokenManager.saveTokens:\n" + JSON.stringify(resp));
            throw resp;
        }
    }    
}

function _getDocumentKey(username) {
    return TYPE + "_" + util.toStorableUserName(username) + "_" + SOURCE;
}
